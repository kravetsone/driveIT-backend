/* eslint-disable */
// @generated by protobuf-ts 2.9.1
// @generated from protobuf file "gtfs-specification.proto" (package "transit_realtime", syntax proto2)
// tslint:disable
//
// Copyright 2015 The GTFS Specifications Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
//
// Protocol definition file for GTFS Realtime.
//
// GTFS Realtime lets transit agencies provide consumers with realtime
// information about disruptions to their service (stations closed, lines not
// operating, important delays etc), location of their vehicles and expected
// arrival times.
//
// This protocol is published at:
// https://github.com/google/transit/tree/master/gtfs-realtime
//
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * The contents of a feed message.
 * A feed is a continuous stream of feed messages. Each message in the stream is
 * obtained as a response to an appropriate HTTP GET request.
 * A realtime feed is always defined with relation to an existing GTFS feed.
 * All the entity ids are resolved with respect to the GTFS feed.
 * Note that "required" and "optional" as stated in this file refer to Protocol
 * Buffer cardinality, not semantic cardinality.  See reference.md at
 * https://github.com/google/transit/tree/master/gtfs-realtime for field
 * semantic cardinality.
 *
 * @generated from protobuf message transit_realtime.FeedMessage
 */
export interface FeedMessage {
    /**
     * Metadata about this feed and feed message.
     *
     * @generated from protobuf field: transit_realtime.FeedHeader header = 1;
     */
    header?: FeedHeader;
    /**
     * Contents of the feed.
     *
     * @generated from protobuf field: repeated transit_realtime.FeedEntity entity = 2;
     */
    entity: FeedEntity[];
}
/**
 * Metadata about a feed, included in feed messages.
 *
 * @generated from protobuf message transit_realtime.FeedHeader
 */
export interface FeedHeader {
    /**
     * Version of the feed specification.
     * The current version is 2.0.
     *
     * @generated from protobuf field: string gtfs_realtime_version = 1;
     */
    gtfsRealtimeVersion: string;
    /**
     * @generated from protobuf field: optional transit_realtime.FeedHeader.Incrementality incrementality = 2;
     */
    incrementality?: FeedHeader_Incrementality;
    /**
     * This timestamp identifies the moment when the content of this feed has been
     * created (in server time). In POSIX time (i.e., number of seconds since
     * January 1st 1970 00:00:00 UTC).
     *
     * @generated from protobuf field: optional uint64 timestamp = 3;
     */
    timestamp?: bigint;
}
/**
 * Determines whether the current fetch is incremental.  Currently,
 * DIFFERENTIAL mode is unsupported and behavior is unspecified for feeds
 * that use this mode.  There are discussions on the GTFS Realtime mailing
 * list around fully specifying the behavior of DIFFERENTIAL mode and the
 * documentation will be updated when those discussions are finalized.
 *
 * @generated from protobuf enum transit_realtime.FeedHeader.Incrementality
 */
export enum FeedHeader_Incrementality {
    /**
     * @generated from protobuf enum value: FULL_DATASET = 0;
     */
    FULL_DATASET = 0,
    /**
     * @generated from protobuf enum value: DIFFERENTIAL = 1;
     */
    DIFFERENTIAL = 1
}
/**
 * A definition (or update) of an entity in the transit feed.
 *
 * @generated from protobuf message transit_realtime.FeedEntity
 */
export interface FeedEntity {
    /**
     * The ids are used only to provide incrementality support. The id should be
     * unique within a FeedMessage. Consequent FeedMessages may contain
     * FeedEntities with the same id. In case of a DIFFERENTIAL update the new
     * FeedEntity with some id will replace the old FeedEntity with the same id
     * (or delete it - see is_deleted below).
     * The actual GTFS entities (e.g. stations, routes, trips) referenced by the
     * feed must be specified by explicit selectors (see EntitySelector below for
     * more info).
     *
     * @generated from protobuf field: string id = 1;
     */
    id: string;
    /**
     * Whether this entity is to be deleted. Relevant only for incremental
     * fetches.
     *
     * @generated from protobuf field: optional bool is_deleted = 2;
     */
    isDeleted?: boolean;
    /**
     * Data about the entity itself. Exactly one of the following fields must be
     * present (unless the entity is being deleted).
     *
     * @generated from protobuf field: optional transit_realtime.TripUpdate trip_update = 3;
     */
    tripUpdate?: TripUpdate;
    /**
     * @generated from protobuf field: optional transit_realtime.VehiclePosition vehicle = 4;
     */
    vehicle?: VehiclePosition;
    /**
     * @generated from protobuf field: optional transit_realtime.Alert alert = 5;
     */
    alert?: Alert;
}
// 
// Entities used in the feed.
// 

/**
 * Realtime update of the progress of a vehicle along a trip.
 * Depending on the value of ScheduleRelationship, a TripUpdate can specify:
 * - A trip that proceeds along the schedule.
 * - A trip that proceeds along a route but has no fixed schedule.
 * - A trip that have been added or removed with regard to schedule.
 *
 * The updates can be for future, predicted arrival/departure events, or for
 * past events that already occurred.
 * Normally, updates should get more precise and more certain (see
 * uncertainty below) as the events gets closer to current time.
 * Even if that is not possible, the information for past events should be
 * precise and certain. In particular, if an update points to time in the past
 * but its update's uncertainty is not 0, the client should conclude that the
 * update is a (wrong) prediction and that the trip has not completed yet.
 *
 * Note that the update can describe a trip that is already completed.
 * To this end, it is enough to provide an update for the last stop of the trip.
 * If the time of that is in the past, the client will conclude from that that
 * the whole trip is in the past (it is possible, although inconsequential, to
 * also provide updates for preceding stops).
 * This option is most relevant for a trip that has completed ahead of schedule,
 * but according to the schedule, the trip is still proceeding at the current
 * time. Removing the updates for this trip could make the client assume
 * that the trip is still proceeding.
 * Note that the feed provider is allowed, but not required, to purge past
 * updates - this is one case where this would be practically useful.
 *
 * @generated from protobuf message transit_realtime.TripUpdate
 */
export interface TripUpdate {
    /**
     * The Trip that this message applies to. There can be at most one
     * TripUpdate entity for each actual trip instance.
     * If there is none, that means there is no prediction information available.
     * It does *not* mean that the trip is progressing according to schedule.
     *
     * @generated from protobuf field: transit_realtime.TripDescriptor trip = 1;
     */
    trip?: TripDescriptor;
    /**
     * Additional information on the vehicle that is serving this trip.
     *
     * @generated from protobuf field: optional transit_realtime.VehicleDescriptor vehicle = 3;
     */
    vehicle?: VehicleDescriptor;
    /**
     * Updates to StopTimes for the trip (both future, i.e., predictions, and in
     * some cases, past ones, i.e., those that already happened).
     * The updates must be sorted by stop_sequence, and apply for all the
     * following stops of the trip up to the next specified one.
     *
     * Example 1:
     * For a trip with 20 stops, a StopTimeUpdate with arrival delay and departure
     * delay of 0 for stop_sequence of the current stop means that the trip is
     * exactly on time.
     *
     * Example 2:
     * For the same trip instance, 3 StopTimeUpdates are provided:
     * - delay of 5 min for stop_sequence 3
     * - delay of 1 min for stop_sequence 8
     * - delay of unspecified duration for stop_sequence 10
     * This will be interpreted as:
     * - stop_sequences 3,4,5,6,7 have delay of 5 min.
     * - stop_sequences 8,9 have delay of 1 min.
     * - stop_sequences 10,... have unknown delay.
     *
     * @generated from protobuf field: repeated transit_realtime.TripUpdate.StopTimeUpdate stop_time_update = 2;
     */
    stopTimeUpdate: TripUpdate_StopTimeUpdate[];
    /**
     * Moment at which the vehicle's real-time progress was measured. In POSIX
     * time (i.e., the number of seconds since January 1st 1970 00:00:00 UTC).
     *
     * @generated from protobuf field: optional uint64 timestamp = 4;
     */
    timestamp?: bigint;
    /**
     * The current schedule deviation for the trip.  Delay should only be
     * specified when the prediction is given relative to some existing schedule
     * in GTFS.
     *
     * Delay (in seconds) can be positive (meaning that the vehicle is late) or
     * negative (meaning that the vehicle is ahead of schedule). Delay of 0
     * means that the vehicle is exactly on time.
     *
     * Delay information in StopTimeUpdates take precedent of trip-level delay
     * information, such that trip-level delay is only propagated until the next
     * stop along the trip with a StopTimeUpdate delay value specified.
     *
     * Feed providers are strongly encouraged to provide a TripUpdate.timestamp
     * value indicating when the delay value was last updated, in order to
     * evaluate the freshness of the data.
     *
     * NOTE: This field is still experimental, and subject to change. It may be
     * formally adopted in the future.
     *
     * @generated from protobuf field: optional int32 delay = 5;
     */
    delay?: number;
}
/**
 * Timing information for a single predicted event (either arrival or
 * departure).
 * Timing consists of delay and/or estimated time, and uncertainty.
 * - delay should be used when the prediction is given relative to some
 *   existing schedule in GTFS.
 * - time should be given whether there is a predicted schedule or not. If
 *   both time and delay are specified, time will take precedence
 *   (although normally, time, if given for a scheduled trip, should be
 *   equal to scheduled time in GTFS + delay).
 *
 * Uncertainty applies equally to both time and delay.
 * The uncertainty roughly specifies the expected error in true delay (but
 * note, we don't yet define its precise statistical meaning). It's possible
 * for the uncertainty to be 0, for example for trains that are driven under
 * computer timing control.
 *
 * @generated from protobuf message transit_realtime.TripUpdate.StopTimeEvent
 */
export interface TripUpdate_StopTimeEvent {
    /**
     * Delay (in seconds) can be positive (meaning that the vehicle is late) or
     * negative (meaning that the vehicle is ahead of schedule). Delay of 0
     * means that the vehicle is exactly on time.
     *
     * @generated from protobuf field: optional int32 delay = 1;
     */
    delay?: number;
    /**
     * Event as absolute time.
     * In Unix time (i.e., number of seconds since January 1st 1970 00:00:00
     * UTC).
     *
     * @generated from protobuf field: optional int64 time = 2;
     */
    time?: bigint;
    /**
     * If uncertainty is omitted, it is interpreted as unknown.
     * If the prediction is unknown or too uncertain, the delay (or time) field
     * should be empty. In such case, the uncertainty field is ignored.
     * To specify a completely certain prediction, set its uncertainty to 0.
     *
     * @generated from protobuf field: optional int32 uncertainty = 3;
     */
    uncertainty?: number;
}
/**
 * Realtime update for arrival and/or departure events for a given stop on a
 * trip. Updates can be supplied for both past and future events.
 * The producer is allowed, although not required, to drop past events.
 *
 * The update is linked to a specific stop either through stop_sequence or
 * stop_id, so one of the fields below must necessarily be set.
 * See the documentation in TripDescriptor for more information.
 *
 * @generated from protobuf message transit_realtime.TripUpdate.StopTimeUpdate
 */
export interface TripUpdate_StopTimeUpdate {
    /**
     * Must be the same as in stop_times.txt in the corresponding GTFS feed.
     *
     * @generated from protobuf field: optional uint32 stop_sequence = 1;
     */
    stopSequence?: number;
    /**
     * Must be the same as in stops.txt in the corresponding GTFS feed.
     *
     * @generated from protobuf field: optional string stop_id = 4;
     */
    stopId?: string;
    /**
     * @generated from protobuf field: optional transit_realtime.TripUpdate.StopTimeEvent arrival = 2;
     */
    arrival?: TripUpdate_StopTimeEvent;
    /**
     * @generated from protobuf field: optional transit_realtime.TripUpdate.StopTimeEvent departure = 3;
     */
    departure?: TripUpdate_StopTimeEvent;
    /**
     * @generated from protobuf field: optional transit_realtime.TripUpdate.StopTimeUpdate.ScheduleRelationship schedule_relationship = 5;
     */
    scheduleRelationship?: TripUpdate_StopTimeUpdate_ScheduleRelationship;
}
/**
 * The relation between this StopTime and the static schedule.
 *
 * @generated from protobuf enum transit_realtime.TripUpdate.StopTimeUpdate.ScheduleRelationship
 */
export enum TripUpdate_StopTimeUpdate_ScheduleRelationship {
    /**
     * The vehicle is proceeding in accordance with its static schedule of
     * stops, although not necessarily according to the times of the schedule.
     * At least one of arrival and departure must be provided. If the schedule
     * for this stop contains both arrival and departure times then so must
     * this update.
     *
     * @generated from protobuf enum value: SCHEDULED = 0;
     */
    SCHEDULED = 0,
    /**
     * The stop is skipped, i.e., the vehicle will not stop at this stop.
     * Arrival and departure are optional.
     *
     * @generated from protobuf enum value: SKIPPED = 1;
     */
    SKIPPED = 1,
    /**
     * No data is given for this stop. The main intention for this value is to
     * give the predictions only for part of a trip, i.e., if the last update
     * for a trip has a NO_DATA specifier, then StopTimes for the rest of the
     * stops in the trip are considered to be unspecified as well.
     * Neither arrival nor departure should be supplied.
     *
     * @generated from protobuf enum value: NO_DATA = 2;
     */
    NO_DATA = 2
}
/**
 * Realtime positioning information for a given vehicle.
 *
 * @generated from protobuf message transit_realtime.VehiclePosition
 */
export interface VehiclePosition {
    /**
     * The Trip that this vehicle is serving.
     * Can be empty or partial if the vehicle can not be identified with a given
     * trip instance.
     *
     * @generated from protobuf field: optional transit_realtime.TripDescriptor trip = 1;
     */
    trip?: TripDescriptor;
    /**
     * Additional information on the vehicle that is serving this trip.
     *
     * @generated from protobuf field: optional transit_realtime.VehicleDescriptor vehicle = 8;
     */
    vehicle?: VehicleDescriptor;
    /**
     * Current position of this vehicle.
     *
     * @generated from protobuf field: optional transit_realtime.Position position = 2;
     */
    position?: Position;
    /**
     * The stop sequence index of the current stop. The meaning of
     * current_stop_sequence (i.e., the stop that it refers to) is determined by
     * current_status.
     * If current_status is missing IN_TRANSIT_TO is assumed.
     *
     * @generated from protobuf field: optional uint32 current_stop_sequence = 3;
     */
    currentStopSequence?: number;
    /**
     * Identifies the current stop. The value must be the same as in stops.txt in
     * the corresponding GTFS feed.
     *
     * @generated from protobuf field: optional string stop_id = 7;
     */
    stopId?: string;
    /**
     * The exact status of the vehicle with respect to the current stop.
     * Ignored if current_stop_sequence is missing.
     *
     * @generated from protobuf field: optional transit_realtime.VehiclePosition.VehicleStopStatus current_status = 4;
     */
    currentStatus?: VehiclePosition_VehicleStopStatus;
    /**
     * Moment at which the vehicle's position was measured. In POSIX time
     * (i.e., number of seconds since January 1st 1970 00:00:00 UTC).
     *
     * @generated from protobuf field: optional uint64 timestamp = 5;
     */
    timestamp?: bigint;
    /**
     * @generated from protobuf field: optional transit_realtime.VehiclePosition.CongestionLevel congestion_level = 6;
     */
    congestionLevel?: VehiclePosition_CongestionLevel;
    /**
     * @generated from protobuf field: optional transit_realtime.VehiclePosition.OccupancyStatus occupancy_status = 9;
     */
    occupancyStatus?: VehiclePosition_OccupancyStatus;
}
/**
 * @generated from protobuf enum transit_realtime.VehiclePosition.VehicleStopStatus
 */
export enum VehiclePosition_VehicleStopStatus {
    /**
     * The vehicle is just about to arrive at the stop (on a stop
     * display, the vehicle symbol typically flashes).
     *
     * @generated from protobuf enum value: INCOMING_AT = 0;
     */
    INCOMING_AT = 0,
    /**
     * The vehicle is standing at the stop.
     *
     * @generated from protobuf enum value: STOPPED_AT = 1;
     */
    STOPPED_AT = 1,
    /**
     * The vehicle has departed and is in transit to the next stop.
     *
     * @generated from protobuf enum value: IN_TRANSIT_TO = 2;
     */
    IN_TRANSIT_TO = 2
}
/**
 * Congestion level that is affecting this vehicle.
 *
 * @generated from protobuf enum transit_realtime.VehiclePosition.CongestionLevel
 */
export enum VehiclePosition_CongestionLevel {
    /**
     * @generated from protobuf enum value: UNKNOWN_CONGESTION_LEVEL = 0;
     */
    UNKNOWN_CONGESTION_LEVEL = 0,
    /**
     * @generated from protobuf enum value: RUNNING_SMOOTHLY = 1;
     */
    RUNNING_SMOOTHLY = 1,
    /**
     * @generated from protobuf enum value: STOP_AND_GO = 2;
     */
    STOP_AND_GO = 2,
    /**
     * @generated from protobuf enum value: CONGESTION = 3;
     */
    CONGESTION = 3,
    /**
     * People leaving their cars.
     *
     * @generated from protobuf enum value: SEVERE_CONGESTION = 4;
     */
    SEVERE_CONGESTION = 4
}
/**
 * The degree of passenger occupancy of the vehicle. This field is still
 * experimental, and subject to change. It may be formally adopted in the
 * future.
 *
 * @generated from protobuf enum transit_realtime.VehiclePosition.OccupancyStatus
 */
export enum VehiclePosition_OccupancyStatus {
    /**
     * The vehicle is considered empty by most measures, and has few or no
     * passengers onboard, but is still accepting passengers.
     *
     * @generated from protobuf enum value: EMPTY = 0;
     */
    EMPTY = 0,
    /**
     * The vehicle has a relatively large percentage of seats available.
     * What percentage of free seats out of the total seats available is to be
     * considered large enough to fall into this category is determined at the
     * discretion of the producer.
     *
     * @generated from protobuf enum value: MANY_SEATS_AVAILABLE = 1;
     */
    MANY_SEATS_AVAILABLE = 1,
    /**
     * The vehicle has a relatively small percentage of seats available.
     * What percentage of free seats out of the total seats available is to be
     * considered small enough to fall into this category is determined at the
     * discretion of the feed producer.
     *
     * @generated from protobuf enum value: FEW_SEATS_AVAILABLE = 2;
     */
    FEW_SEATS_AVAILABLE = 2,
    /**
     * The vehicle can currently accommodate only standing passengers.
     *
     * @generated from protobuf enum value: STANDING_ROOM_ONLY = 3;
     */
    STANDING_ROOM_ONLY = 3,
    /**
     * The vehicle can currently accommodate only standing passengers
     * and has limited space for them.
     *
     * @generated from protobuf enum value: CRUSHED_STANDING_ROOM_ONLY = 4;
     */
    CRUSHED_STANDING_ROOM_ONLY = 4,
    /**
     * The vehicle is considered full by most measures, but may still be
     * allowing passengers to board.
     *
     * @generated from protobuf enum value: FULL = 5;
     */
    FULL = 5,
    /**
     * The vehicle is not accepting additional passengers.
     *
     * @generated from protobuf enum value: NOT_ACCEPTING_PASSENGERS = 6;
     */
    NOT_ACCEPTING_PASSENGERS = 6
}
/**
 * An alert, indicating some sort of incident in the public transit network.
 *
 * @generated from protobuf message transit_realtime.Alert
 */
export interface Alert {
    /**
     * Time when the alert should be shown to the user. If missing, the
     * alert will be shown as long as it appears in the feed.
     * If multiple ranges are given, the alert will be shown during all of them.
     *
     * @generated from protobuf field: repeated transit_realtime.TimeRange active_period = 1;
     */
    activePeriod: TimeRange[];
    /**
     * Entities whose users we should notify of this alert.
     *
     * @generated from protobuf field: repeated transit_realtime.EntitySelector informed_entity = 5;
     */
    informedEntity: EntitySelector[];
    /**
     * @generated from protobuf field: optional transit_realtime.Alert.Cause cause = 6;
     */
    cause?: Alert_Cause;
    /**
     * @generated from protobuf field: optional transit_realtime.Alert.Effect effect = 7;
     */
    effect?: Alert_Effect;
    /**
     * The URL which provides additional information about the alert.
     *
     * @generated from protobuf field: optional transit_realtime.TranslatedString url = 8;
     */
    url?: TranslatedString;
    /**
     * Alert header. Contains a short summary of the alert text as plain-text.
     *
     * @generated from protobuf field: optional transit_realtime.TranslatedString header_text = 10;
     */
    headerText?: TranslatedString;
    /**
     * Full description for the alert as plain-text. The information in the
     * description should add to the information of the header.
     *
     * @generated from protobuf field: optional transit_realtime.TranslatedString description_text = 11;
     */
    descriptionText?: TranslatedString;
}
/**
 * Cause of this alert.
 *
 * @generated from protobuf enum transit_realtime.Alert.Cause
 */
export enum Alert_Cause {
    /**
     * @generated synthetic value - protobuf-ts requires all enums to have a 0 value
     */
    UNSPECIFIED$ = 0,
    /**
     * @generated from protobuf enum value: UNKNOWN_CAUSE = 1;
     */
    UNKNOWN_CAUSE = 1,
    /**
     * Not machine-representable.
     *
     * @generated from protobuf enum value: OTHER_CAUSE = 2;
     */
    OTHER_CAUSE = 2,
    /**
     * @generated from protobuf enum value: TECHNICAL_PROBLEM = 3;
     */
    TECHNICAL_PROBLEM = 3,
    /**
     * Public transit agency employees stopped working.
     *
     * @generated from protobuf enum value: STRIKE = 4;
     */
    STRIKE = 4,
    /**
     * People are blocking the streets.
     *
     * @generated from protobuf enum value: DEMONSTRATION = 5;
     */
    DEMONSTRATION = 5,
    /**
     * @generated from protobuf enum value: ACCIDENT = 6;
     */
    ACCIDENT = 6,
    /**
     * @generated from protobuf enum value: HOLIDAY = 7;
     */
    HOLIDAY = 7,
    /**
     * @generated from protobuf enum value: WEATHER = 8;
     */
    WEATHER = 8,
    /**
     * @generated from protobuf enum value: MAINTENANCE = 9;
     */
    MAINTENANCE = 9,
    /**
     * @generated from protobuf enum value: CONSTRUCTION = 10;
     */
    CONSTRUCTION = 10,
    /**
     * @generated from protobuf enum value: POLICE_ACTIVITY = 11;
     */
    POLICE_ACTIVITY = 11,
    /**
     * @generated from protobuf enum value: MEDICAL_EMERGENCY = 12;
     */
    MEDICAL_EMERGENCY = 12
}
/**
 * What is the effect of this problem on the affected entity.
 *
 * @generated from protobuf enum transit_realtime.Alert.Effect
 */
export enum Alert_Effect {
    /**
     * @generated synthetic value - protobuf-ts requires all enums to have a 0 value
     */
    UNSPECIFIED$ = 0,
    /**
     * @generated from protobuf enum value: NO_SERVICE = 1;
     */
    NO_SERVICE = 1,
    /**
     * @generated from protobuf enum value: REDUCED_SERVICE = 2;
     */
    REDUCED_SERVICE = 2,
    /**
     * We don't care about INsignificant delays: they are hard to detect, have
     * little impact on the user, and would clutter the results as they are too
     * frequent.
     *
     * @generated from protobuf enum value: SIGNIFICANT_DELAYS = 3;
     */
    SIGNIFICANT_DELAYS = 3,
    /**
     * @generated from protobuf enum value: DETOUR = 4;
     */
    DETOUR = 4,
    /**
     * @generated from protobuf enum value: ADDITIONAL_SERVICE = 5;
     */
    ADDITIONAL_SERVICE = 5,
    /**
     * @generated from protobuf enum value: MODIFIED_SERVICE = 6;
     */
    MODIFIED_SERVICE = 6,
    /**
     * @generated from protobuf enum value: OTHER_EFFECT = 7;
     */
    OTHER_EFFECT = 7,
    /**
     * @generated from protobuf enum value: UNKNOWN_EFFECT = 8;
     */
    UNKNOWN_EFFECT = 8,
    /**
     * @generated from protobuf enum value: STOP_MOVED = 9;
     */
    STOP_MOVED = 9
}
// 
// Low level data structures used above.
// 

/**
 * A time interval. The interval is considered active at time 't' if 't' is
 * greater than or equal to the start time and less than the end time.
 *
 * @generated from protobuf message transit_realtime.TimeRange
 */
export interface TimeRange {
    /**
     * Start time, in POSIX time (i.e., number of seconds since January 1st 1970
     * 00:00:00 UTC).
     * If missing, the interval starts at minus infinity.
     *
     * @generated from protobuf field: optional uint64 start = 1;
     */
    start?: bigint;
    /**
     * End time, in POSIX time (i.e., number of seconds since January 1st 1970
     * 00:00:00 UTC).
     * If missing, the interval ends at plus infinity.
     *
     * @generated from protobuf field: optional uint64 end = 2;
     */
    end?: bigint;
}
/**
 * A position.
 *
 * @generated from protobuf message transit_realtime.Position
 */
export interface Position {
    /**
     * Degrees North, in the WGS-84 coordinate system.
     *
     * @generated from protobuf field: float latitude = 1;
     */
    latitude: number;
    /**
     * Degrees East, in the WGS-84 coordinate system.
     *
     * @generated from protobuf field: float longitude = 2;
     */
    longitude: number;
    /**
     * Bearing, in degrees, clockwise from North, i.e., 0 is North and 90 is East.
     * This can be the compass bearing, or the direction towards the next stop
     * or intermediate location.
     * This should not be direction deduced from the sequence of previous
     * positions, which can be computed from previous data.
     *
     * @generated from protobuf field: optional float bearing = 3;
     */
    bearing?: number;
    /**
     * Odometer value, in meters.
     *
     * @generated from protobuf field: optional double odometer = 4;
     */
    odometer?: number;
    /**
     * Momentary speed measured by the vehicle, in meters per second.
     *
     * @generated from protobuf field: optional float speed = 5;
     */
    speed?: number;
}
/**
 * A descriptor that identifies an instance of a GTFS trip, or all instances of
 * a trip along a route.
 * - To specify a single trip instance, the trip_id (and if necessary,
 *   start_time) is set. If route_id is also set, then it should be same as one
 *   that the given trip corresponds to.
 * - To specify all the trips along a given route, only the route_id should be
 *   set. Note that if the trip_id is not known, then stop sequence ids in
 *   TripUpdate are not sufficient, and stop_ids must be provided as well. In
 *   addition, absolute arrival/departure times must be provided.
 *
 * @generated from protobuf message transit_realtime.TripDescriptor
 */
export interface TripDescriptor {
    /**
     * The trip_id from the GTFS feed that this selector refers to.
     * For non frequency-based trips, this field is enough to uniquely identify
     * the trip. For frequency-based trip, start_time and start_date might also be
     * necessary.
     *
     * @generated from protobuf field: optional string trip_id = 1;
     */
    tripId?: string;
    /**
     * The route_id from the GTFS that this selector refers to.
     *
     * @generated from protobuf field: optional string route_id = 5;
     */
    routeId?: string;
    /**
     * The direction_id from the GTFS feed trips.txt file, indicating the
     * direction of travel for trips this selector refers to. This field is
     * still experimental, and subject to change. It may be formally adopted in
     * the future.
     *
     * @generated from protobuf field: optional uint32 direction_id = 6;
     */
    directionId?: number;
    /**
     * The initially scheduled start time of this trip instance.
     * When the trip_id corresponds to a non-frequency-based trip, this field
     * should either be omitted or be equal to the value in the GTFS feed. When
     * the trip_id corresponds to a frequency-based trip, the start_time must be
     * specified for trip updates and vehicle positions. If the trip corresponds
     * to exact_times=1 GTFS record, then start_time must be some multiple
     * (including zero) of headway_secs later than frequencies.txt start_time for
     * the corresponding time period. If the trip corresponds to exact_times=0,
     * then its start_time may be arbitrary, and is initially expected to be the
     * first departure of the trip. Once established, the start_time of this
     * frequency-based trip should be considered immutable, even if the first
     * departure time changes -- that time change may instead be reflected in a
     * StopTimeUpdate.
     * Format and semantics of the field is same as that of
     * GTFS/frequencies.txt/start_time, e.g., 11:15:35 or 25:15:35.
     *
     * @generated from protobuf field: optional string start_time = 2;
     */
    startTime?: string;
    /**
     * The scheduled start date of this trip instance.
     * Must be provided to disambiguate trips that are so late as to collide with
     * a scheduled trip on a next day. For example, for a train that departs 8:00
     * and 20:00 every day, and is 12 hours late, there would be two distinct
     * trips on the same time.
     * This field can be provided but is not mandatory for schedules in which such
     * collisions are impossible - for example, a service running on hourly
     * schedule where a vehicle that is one hour late is not considered to be
     * related to schedule anymore.
     * In YYYYMMDD format.
     *
     * @generated from protobuf field: optional string start_date = 3;
     */
    startDate?: string;
    /**
     * @generated from protobuf field: optional transit_realtime.TripDescriptor.ScheduleRelationship schedule_relationship = 4;
     */
    scheduleRelationship?: TripDescriptor_ScheduleRelationship;
}
/**
 * The relation between this trip and the static schedule. If a trip is done
 * in accordance with temporary schedule, not reflected in GTFS, then it
 * shouldn't be marked as SCHEDULED, but likely as ADDED.
 *
 * @generated from protobuf enum transit_realtime.TripDescriptor.ScheduleRelationship
 */
export enum TripDescriptor_ScheduleRelationship {
    /**
     * Trip that is running in accordance with its GTFS schedule, or is close
     * enough to the scheduled trip to be associated with it.
     *
     * @generated from protobuf enum value: SCHEDULED = 0;
     */
    SCHEDULED = 0,
    /**
     * An extra trip that was added in addition to a running schedule, for
     * example, to replace a broken vehicle or to respond to sudden passenger
     * load.
     *
     * @generated from protobuf enum value: ADDED = 1;
     */
    ADDED = 1,
    /**
     * A trip that is running with no schedule associated to it, for example, if
     * there is no schedule at all.
     *
     * @generated from protobuf enum value: UNSCHEDULED = 2;
     */
    UNSCHEDULED = 2,
    /**
     * A trip that existed in the schedule but was removed.
     *
     * @generated from protobuf enum value: CANCELED = 3;
     */
    CANCELED = 3
}
/**
 * Identification information for the vehicle performing the trip.
 *
 * @generated from protobuf message transit_realtime.VehicleDescriptor
 */
export interface VehicleDescriptor {
    /**
     * Internal system identification of the vehicle. Should be unique per
     * vehicle, and can be used for tracking the vehicle as it proceeds through
     * the system.
     *
     * @generated from protobuf field: optional string id = 1;
     */
    id?: string;
    /**
     * User visible label, i.e., something that must be shown to the passenger to
     * help identify the correct vehicle.
     *
     * @generated from protobuf field: optional string label = 2;
     */
    label?: string;
    /**
     * The license plate of the vehicle.
     *
     * @generated from protobuf field: optional string license_plate = 3;
     */
    licensePlate?: string;
}
/**
 * A selector for an entity in a GTFS feed.
 *
 * @generated from protobuf message transit_realtime.EntitySelector
 */
export interface EntitySelector {
    /**
     * The values of the fields should correspond to the appropriate fields in the
     * GTFS feed.
     * At least one specifier must be given. If several are given, then the
     * matching has to apply to all the given specifiers.
     *
     * @generated from protobuf field: optional string agency_id = 1;
     */
    agencyId?: string;
    /**
     * @generated from protobuf field: optional string route_id = 2;
     */
    routeId?: string;
    /**
     * corresponds to route_type in GTFS.
     *
     * @generated from protobuf field: optional int32 route_type = 3;
     */
    routeType?: number;
    /**
     * @generated from protobuf field: optional transit_realtime.TripDescriptor trip = 4;
     */
    trip?: TripDescriptor;
    /**
     * @generated from protobuf field: optional string stop_id = 5;
     */
    stopId?: string;
}
/**
 * An internationalized message containing per-language versions of a snippet of
 * text or a URL.
 * One of the strings from a message will be picked up. The resolution proceeds
 * as follows:
 * 1. If the UI language matches the language code of a translation,
 *    the first matching translation is picked.
 * 2. If a default UI language (e.g., English) matches the language code of a
 *    translation, the first matching translation is picked.
 * 3. If some translation has an unspecified language code, that translation is
 *    picked.
 *
 * @generated from protobuf message transit_realtime.TranslatedString
 */
export interface TranslatedString {
    /**
     * At least one translation must be provided.
     *
     * @generated from protobuf field: repeated transit_realtime.TranslatedString.Translation translation = 1;
     */
    translation: TranslatedString_Translation[];
}
/**
 * @generated from protobuf message transit_realtime.TranslatedString.Translation
 */
export interface TranslatedString_Translation {
    /**
     * A UTF-8 string containing the message.
     *
     * @generated from protobuf field: string text = 1;
     */
    text: string;
    /**
     * BCP-47 language code. Can be omitted if the language is unknown or if
     * no i18n is done at all for the feed. At most one translation is
     * allowed to have an unspecified language tag.
     *
     * @generated from protobuf field: optional string language = 2;
     */
    language?: string;
}
// @generated message type with reflection information, may provide speed optimized methods
class FeedMessage$Type extends MessageType<FeedMessage> {
    constructor() {
        super("transit_realtime.FeedMessage", [
            { no: 1, name: "header", kind: "message", T: () => FeedHeader },
            { no: 2, name: "entity", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => FeedEntity }
        ]);
    }
    create(value?: PartialMessage<FeedMessage>): FeedMessage {
        const message = { entity: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<FeedMessage>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FeedMessage): FeedMessage {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* transit_realtime.FeedHeader header */ 1:
                    message.header = FeedHeader.internalBinaryRead(reader, reader.uint32(), options, message.header);
                    break;
                case /* repeated transit_realtime.FeedEntity entity */ 2:
                    message.entity.push(FeedEntity.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FeedMessage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* transit_realtime.FeedHeader header = 1; */
        if (message.header)
            FeedHeader.internalBinaryWrite(message.header, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated transit_realtime.FeedEntity entity = 2; */
        for (let i = 0; i < message.entity.length; i++)
            FeedEntity.internalBinaryWrite(message.entity[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message transit_realtime.FeedMessage
 */
export const FeedMessage = new FeedMessage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FeedHeader$Type extends MessageType<FeedHeader> {
    constructor() {
        super("transit_realtime.FeedHeader", [
            { no: 1, name: "gtfs_realtime_version", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "incrementality", kind: "enum", opt: true, T: () => ["transit_realtime.FeedHeader.Incrementality", FeedHeader_Incrementality] },
            { no: 3, name: "timestamp", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<FeedHeader>): FeedHeader {
        const message = { gtfsRealtimeVersion: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<FeedHeader>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FeedHeader): FeedHeader {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string gtfs_realtime_version */ 1:
                    message.gtfsRealtimeVersion = reader.string();
                    break;
                case /* optional transit_realtime.FeedHeader.Incrementality incrementality */ 2:
                    message.incrementality = reader.int32();
                    break;
                case /* optional uint64 timestamp */ 3:
                    message.timestamp = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FeedHeader, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string gtfs_realtime_version = 1; */
        if (message.gtfsRealtimeVersion !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.gtfsRealtimeVersion);
        /* optional transit_realtime.FeedHeader.Incrementality incrementality = 2; */
        if (message.incrementality !== undefined)
            writer.tag(2, WireType.Varint).int32(message.incrementality);
        /* optional uint64 timestamp = 3; */
        if (message.timestamp !== undefined)
            writer.tag(3, WireType.Varint).uint64(message.timestamp);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message transit_realtime.FeedHeader
 */
export const FeedHeader = new FeedHeader$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FeedEntity$Type extends MessageType<FeedEntity> {
    constructor() {
        super("transit_realtime.FeedEntity", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "is_deleted", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "trip_update", kind: "message", T: () => TripUpdate },
            { no: 4, name: "vehicle", kind: "message", T: () => VehiclePosition },
            { no: 5, name: "alert", kind: "message", T: () => Alert }
        ]);
    }
    create(value?: PartialMessage<FeedEntity>): FeedEntity {
        const message = { id: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<FeedEntity>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FeedEntity): FeedEntity {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* optional bool is_deleted */ 2:
                    message.isDeleted = reader.bool();
                    break;
                case /* optional transit_realtime.TripUpdate trip_update */ 3:
                    message.tripUpdate = TripUpdate.internalBinaryRead(reader, reader.uint32(), options, message.tripUpdate);
                    break;
                case /* optional transit_realtime.VehiclePosition vehicle */ 4:
                    message.vehicle = VehiclePosition.internalBinaryRead(reader, reader.uint32(), options, message.vehicle);
                    break;
                case /* optional transit_realtime.Alert alert */ 5:
                    message.alert = Alert.internalBinaryRead(reader, reader.uint32(), options, message.alert);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FeedEntity, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* optional bool is_deleted = 2; */
        if (message.isDeleted !== undefined)
            writer.tag(2, WireType.Varint).bool(message.isDeleted);
        /* optional transit_realtime.TripUpdate trip_update = 3; */
        if (message.tripUpdate)
            TripUpdate.internalBinaryWrite(message.tripUpdate, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* optional transit_realtime.VehiclePosition vehicle = 4; */
        if (message.vehicle)
            VehiclePosition.internalBinaryWrite(message.vehicle, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* optional transit_realtime.Alert alert = 5; */
        if (message.alert)
            Alert.internalBinaryWrite(message.alert, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message transit_realtime.FeedEntity
 */
export const FeedEntity = new FeedEntity$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TripUpdate$Type extends MessageType<TripUpdate> {
    constructor() {
        super("transit_realtime.TripUpdate", [
            { no: 1, name: "trip", kind: "message", T: () => TripDescriptor },
            { no: 3, name: "vehicle", kind: "message", T: () => VehicleDescriptor },
            { no: 2, name: "stop_time_update", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TripUpdate_StopTimeUpdate },
            { no: 4, name: "timestamp", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "delay", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<TripUpdate>): TripUpdate {
        const message = { stopTimeUpdate: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TripUpdate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TripUpdate): TripUpdate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* transit_realtime.TripDescriptor trip */ 1:
                    message.trip = TripDescriptor.internalBinaryRead(reader, reader.uint32(), options, message.trip);
                    break;
                case /* optional transit_realtime.VehicleDescriptor vehicle */ 3:
                    message.vehicle = VehicleDescriptor.internalBinaryRead(reader, reader.uint32(), options, message.vehicle);
                    break;
                case /* repeated transit_realtime.TripUpdate.StopTimeUpdate stop_time_update */ 2:
                    message.stopTimeUpdate.push(TripUpdate_StopTimeUpdate.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional uint64 timestamp */ 4:
                    message.timestamp = reader.uint64().toBigInt();
                    break;
                case /* optional int32 delay */ 5:
                    message.delay = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TripUpdate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* transit_realtime.TripDescriptor trip = 1; */
        if (message.trip)
            TripDescriptor.internalBinaryWrite(message.trip, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* optional transit_realtime.VehicleDescriptor vehicle = 3; */
        if (message.vehicle)
            VehicleDescriptor.internalBinaryWrite(message.vehicle, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* repeated transit_realtime.TripUpdate.StopTimeUpdate stop_time_update = 2; */
        for (let i = 0; i < message.stopTimeUpdate.length; i++)
            TripUpdate_StopTimeUpdate.internalBinaryWrite(message.stopTimeUpdate[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* optional uint64 timestamp = 4; */
        if (message.timestamp !== undefined)
            writer.tag(4, WireType.Varint).uint64(message.timestamp);
        /* optional int32 delay = 5; */
        if (message.delay !== undefined)
            writer.tag(5, WireType.Varint).int32(message.delay);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message transit_realtime.TripUpdate
 */
export const TripUpdate = new TripUpdate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TripUpdate_StopTimeEvent$Type extends MessageType<TripUpdate_StopTimeEvent> {
    constructor() {
        super("transit_realtime.TripUpdate.StopTimeEvent", [
            { no: 1, name: "delay", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "time", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "uncertainty", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<TripUpdate_StopTimeEvent>): TripUpdate_StopTimeEvent {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TripUpdate_StopTimeEvent>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TripUpdate_StopTimeEvent): TripUpdate_StopTimeEvent {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 delay */ 1:
                    message.delay = reader.int32();
                    break;
                case /* optional int64 time */ 2:
                    message.time = reader.int64().toBigInt();
                    break;
                case /* optional int32 uncertainty */ 3:
                    message.uncertainty = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TripUpdate_StopTimeEvent, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 delay = 1; */
        if (message.delay !== undefined)
            writer.tag(1, WireType.Varint).int32(message.delay);
        /* optional int64 time = 2; */
        if (message.time !== undefined)
            writer.tag(2, WireType.Varint).int64(message.time);
        /* optional int32 uncertainty = 3; */
        if (message.uncertainty !== undefined)
            writer.tag(3, WireType.Varint).int32(message.uncertainty);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message transit_realtime.TripUpdate.StopTimeEvent
 */
export const TripUpdate_StopTimeEvent = new TripUpdate_StopTimeEvent$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TripUpdate_StopTimeUpdate$Type extends MessageType<TripUpdate_StopTimeUpdate> {
    constructor() {
        super("transit_realtime.TripUpdate.StopTimeUpdate", [
            { no: 1, name: "stop_sequence", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "stop_id", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "arrival", kind: "message", T: () => TripUpdate_StopTimeEvent },
            { no: 3, name: "departure", kind: "message", T: () => TripUpdate_StopTimeEvent },
            { no: 5, name: "schedule_relationship", kind: "enum", opt: true, T: () => ["transit_realtime.TripUpdate.StopTimeUpdate.ScheduleRelationship", TripUpdate_StopTimeUpdate_ScheduleRelationship] }
        ]);
    }
    create(value?: PartialMessage<TripUpdate_StopTimeUpdate>): TripUpdate_StopTimeUpdate {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TripUpdate_StopTimeUpdate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TripUpdate_StopTimeUpdate): TripUpdate_StopTimeUpdate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 stop_sequence */ 1:
                    message.stopSequence = reader.uint32();
                    break;
                case /* optional string stop_id */ 4:
                    message.stopId = reader.string();
                    break;
                case /* optional transit_realtime.TripUpdate.StopTimeEvent arrival */ 2:
                    message.arrival = TripUpdate_StopTimeEvent.internalBinaryRead(reader, reader.uint32(), options, message.arrival);
                    break;
                case /* optional transit_realtime.TripUpdate.StopTimeEvent departure */ 3:
                    message.departure = TripUpdate_StopTimeEvent.internalBinaryRead(reader, reader.uint32(), options, message.departure);
                    break;
                case /* optional transit_realtime.TripUpdate.StopTimeUpdate.ScheduleRelationship schedule_relationship */ 5:
                    message.scheduleRelationship = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TripUpdate_StopTimeUpdate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 stop_sequence = 1; */
        if (message.stopSequence !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.stopSequence);
        /* optional string stop_id = 4; */
        if (message.stopId !== undefined)
            writer.tag(4, WireType.LengthDelimited).string(message.stopId);
        /* optional transit_realtime.TripUpdate.StopTimeEvent arrival = 2; */
        if (message.arrival)
            TripUpdate_StopTimeEvent.internalBinaryWrite(message.arrival, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* optional transit_realtime.TripUpdate.StopTimeEvent departure = 3; */
        if (message.departure)
            TripUpdate_StopTimeEvent.internalBinaryWrite(message.departure, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* optional transit_realtime.TripUpdate.StopTimeUpdate.ScheduleRelationship schedule_relationship = 5; */
        if (message.scheduleRelationship !== undefined)
            writer.tag(5, WireType.Varint).int32(message.scheduleRelationship);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message transit_realtime.TripUpdate.StopTimeUpdate
 */
export const TripUpdate_StopTimeUpdate = new TripUpdate_StopTimeUpdate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class VehiclePosition$Type extends MessageType<VehiclePosition> {
    constructor() {
        super("transit_realtime.VehiclePosition", [
            { no: 1, name: "trip", kind: "message", T: () => TripDescriptor },
            { no: 8, name: "vehicle", kind: "message", T: () => VehicleDescriptor },
            { no: 2, name: "position", kind: "message", T: () => Position },
            { no: 3, name: "current_stop_sequence", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "stop_id", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "current_status", kind: "enum", opt: true, T: () => ["transit_realtime.VehiclePosition.VehicleStopStatus", VehiclePosition_VehicleStopStatus] },
            { no: 5, name: "timestamp", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "congestion_level", kind: "enum", opt: true, T: () => ["transit_realtime.VehiclePosition.CongestionLevel", VehiclePosition_CongestionLevel] },
            { no: 9, name: "occupancy_status", kind: "enum", opt: true, T: () => ["transit_realtime.VehiclePosition.OccupancyStatus", VehiclePosition_OccupancyStatus] }
        ]);
    }
    create(value?: PartialMessage<VehiclePosition>): VehiclePosition {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<VehiclePosition>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: VehiclePosition): VehiclePosition {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional transit_realtime.TripDescriptor trip */ 1:
                    message.trip = TripDescriptor.internalBinaryRead(reader, reader.uint32(), options, message.trip);
                    break;
                case /* optional transit_realtime.VehicleDescriptor vehicle */ 8:
                    message.vehicle = VehicleDescriptor.internalBinaryRead(reader, reader.uint32(), options, message.vehicle);
                    break;
                case /* optional transit_realtime.Position position */ 2:
                    message.position = Position.internalBinaryRead(reader, reader.uint32(), options, message.position);
                    break;
                case /* optional uint32 current_stop_sequence */ 3:
                    message.currentStopSequence = reader.uint32();
                    break;
                case /* optional string stop_id */ 7:
                    message.stopId = reader.string();
                    break;
                case /* optional transit_realtime.VehiclePosition.VehicleStopStatus current_status */ 4:
                    message.currentStatus = reader.int32();
                    break;
                case /* optional uint64 timestamp */ 5:
                    message.timestamp = reader.uint64().toBigInt();
                    break;
                case /* optional transit_realtime.VehiclePosition.CongestionLevel congestion_level */ 6:
                    message.congestionLevel = reader.int32();
                    break;
                case /* optional transit_realtime.VehiclePosition.OccupancyStatus occupancy_status */ 9:
                    message.occupancyStatus = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: VehiclePosition, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional transit_realtime.TripDescriptor trip = 1; */
        if (message.trip)
            TripDescriptor.internalBinaryWrite(message.trip, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* optional transit_realtime.VehicleDescriptor vehicle = 8; */
        if (message.vehicle)
            VehicleDescriptor.internalBinaryWrite(message.vehicle, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* optional transit_realtime.Position position = 2; */
        if (message.position)
            Position.internalBinaryWrite(message.position, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 current_stop_sequence = 3; */
        if (message.currentStopSequence !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.currentStopSequence);
        /* optional string stop_id = 7; */
        if (message.stopId !== undefined)
            writer.tag(7, WireType.LengthDelimited).string(message.stopId);
        /* optional transit_realtime.VehiclePosition.VehicleStopStatus current_status = 4; */
        if (message.currentStatus !== undefined)
            writer.tag(4, WireType.Varint).int32(message.currentStatus);
        /* optional uint64 timestamp = 5; */
        if (message.timestamp !== undefined)
            writer.tag(5, WireType.Varint).uint64(message.timestamp);
        /* optional transit_realtime.VehiclePosition.CongestionLevel congestion_level = 6; */
        if (message.congestionLevel !== undefined)
            writer.tag(6, WireType.Varint).int32(message.congestionLevel);
        /* optional transit_realtime.VehiclePosition.OccupancyStatus occupancy_status = 9; */
        if (message.occupancyStatus !== undefined)
            writer.tag(9, WireType.Varint).int32(message.occupancyStatus);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message transit_realtime.VehiclePosition
 */
export const VehiclePosition = new VehiclePosition$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Alert$Type extends MessageType<Alert> {
    constructor() {
        super("transit_realtime.Alert", [
            { no: 1, name: "active_period", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TimeRange },
            { no: 5, name: "informed_entity", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => EntitySelector },
            { no: 6, name: "cause", kind: "enum", opt: true, T: () => ["transit_realtime.Alert.Cause", Alert_Cause] },
            { no: 7, name: "effect", kind: "enum", opt: true, T: () => ["transit_realtime.Alert.Effect", Alert_Effect] },
            { no: 8, name: "url", kind: "message", T: () => TranslatedString },
            { no: 10, name: "header_text", kind: "message", T: () => TranslatedString },
            { no: 11, name: "description_text", kind: "message", T: () => TranslatedString }
        ]);
    }
    create(value?: PartialMessage<Alert>): Alert {
        const message = { activePeriod: [], informedEntity: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Alert>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Alert): Alert {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated transit_realtime.TimeRange active_period */ 1:
                    message.activePeriod.push(TimeRange.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated transit_realtime.EntitySelector informed_entity */ 5:
                    message.informedEntity.push(EntitySelector.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional transit_realtime.Alert.Cause cause */ 6:
                    message.cause = reader.int32();
                    break;
                case /* optional transit_realtime.Alert.Effect effect */ 7:
                    message.effect = reader.int32();
                    break;
                case /* optional transit_realtime.TranslatedString url */ 8:
                    message.url = TranslatedString.internalBinaryRead(reader, reader.uint32(), options, message.url);
                    break;
                case /* optional transit_realtime.TranslatedString header_text */ 10:
                    message.headerText = TranslatedString.internalBinaryRead(reader, reader.uint32(), options, message.headerText);
                    break;
                case /* optional transit_realtime.TranslatedString description_text */ 11:
                    message.descriptionText = TranslatedString.internalBinaryRead(reader, reader.uint32(), options, message.descriptionText);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Alert, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated transit_realtime.TimeRange active_period = 1; */
        for (let i = 0; i < message.activePeriod.length; i++)
            TimeRange.internalBinaryWrite(message.activePeriod[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated transit_realtime.EntitySelector informed_entity = 5; */
        for (let i = 0; i < message.informedEntity.length; i++)
            EntitySelector.internalBinaryWrite(message.informedEntity[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* optional transit_realtime.Alert.Cause cause = 6; */
        if (message.cause !== undefined)
            writer.tag(6, WireType.Varint).int32(message.cause);
        /* optional transit_realtime.Alert.Effect effect = 7; */
        if (message.effect !== undefined)
            writer.tag(7, WireType.Varint).int32(message.effect);
        /* optional transit_realtime.TranslatedString url = 8; */
        if (message.url)
            TranslatedString.internalBinaryWrite(message.url, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* optional transit_realtime.TranslatedString header_text = 10; */
        if (message.headerText)
            TranslatedString.internalBinaryWrite(message.headerText, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* optional transit_realtime.TranslatedString description_text = 11; */
        if (message.descriptionText)
            TranslatedString.internalBinaryWrite(message.descriptionText, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message transit_realtime.Alert
 */
export const Alert = new Alert$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TimeRange$Type extends MessageType<TimeRange> {
    constructor() {
        super("transit_realtime.TimeRange", [
            { no: 1, name: "start", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "end", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<TimeRange>): TimeRange {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TimeRange>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TimeRange): TimeRange {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint64 start */ 1:
                    message.start = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 end */ 2:
                    message.end = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TimeRange, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint64 start = 1; */
        if (message.start !== undefined)
            writer.tag(1, WireType.Varint).uint64(message.start);
        /* optional uint64 end = 2; */
        if (message.end !== undefined)
            writer.tag(2, WireType.Varint).uint64(message.end);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message transit_realtime.TimeRange
 */
export const TimeRange = new TimeRange$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Position$Type extends MessageType<Position> {
    constructor() {
        super("transit_realtime.Position", [
            { no: 1, name: "latitude", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 2, name: "longitude", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 3, name: "bearing", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 4, name: "odometer", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 5, name: "speed", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<Position>): Position {
        const message = { latitude: 0, longitude: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Position>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Position): Position {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* float latitude */ 1:
                    message.latitude = reader.float();
                    break;
                case /* float longitude */ 2:
                    message.longitude = reader.float();
                    break;
                case /* optional float bearing */ 3:
                    message.bearing = reader.float();
                    break;
                case /* optional double odometer */ 4:
                    message.odometer = reader.double();
                    break;
                case /* optional float speed */ 5:
                    message.speed = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Position, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* float latitude = 1; */
        if (message.latitude !== 0)
            writer.tag(1, WireType.Bit32).float(message.latitude);
        /* float longitude = 2; */
        if (message.longitude !== 0)
            writer.tag(2, WireType.Bit32).float(message.longitude);
        /* optional float bearing = 3; */
        if (message.bearing !== undefined)
            writer.tag(3, WireType.Bit32).float(message.bearing);
        /* optional double odometer = 4; */
        if (message.odometer !== undefined)
            writer.tag(4, WireType.Bit64).double(message.odometer);
        /* optional float speed = 5; */
        if (message.speed !== undefined)
            writer.tag(5, WireType.Bit32).float(message.speed);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message transit_realtime.Position
 */
export const Position = new Position$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TripDescriptor$Type extends MessageType<TripDescriptor> {
    constructor() {
        super("transit_realtime.TripDescriptor", [
            { no: 1, name: "trip_id", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "route_id", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "direction_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "start_time", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "start_date", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "schedule_relationship", kind: "enum", opt: true, T: () => ["transit_realtime.TripDescriptor.ScheduleRelationship", TripDescriptor_ScheduleRelationship] }
        ]);
    }
    create(value?: PartialMessage<TripDescriptor>): TripDescriptor {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TripDescriptor>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TripDescriptor): TripDescriptor {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string trip_id */ 1:
                    message.tripId = reader.string();
                    break;
                case /* optional string route_id */ 5:
                    message.routeId = reader.string();
                    break;
                case /* optional uint32 direction_id */ 6:
                    message.directionId = reader.uint32();
                    break;
                case /* optional string start_time */ 2:
                    message.startTime = reader.string();
                    break;
                case /* optional string start_date */ 3:
                    message.startDate = reader.string();
                    break;
                case /* optional transit_realtime.TripDescriptor.ScheduleRelationship schedule_relationship */ 4:
                    message.scheduleRelationship = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TripDescriptor, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string trip_id = 1; */
        if (message.tripId !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.tripId);
        /* optional string route_id = 5; */
        if (message.routeId !== undefined)
            writer.tag(5, WireType.LengthDelimited).string(message.routeId);
        /* optional uint32 direction_id = 6; */
        if (message.directionId !== undefined)
            writer.tag(6, WireType.Varint).uint32(message.directionId);
        /* optional string start_time = 2; */
        if (message.startTime !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.startTime);
        /* optional string start_date = 3; */
        if (message.startDate !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.startDate);
        /* optional transit_realtime.TripDescriptor.ScheduleRelationship schedule_relationship = 4; */
        if (message.scheduleRelationship !== undefined)
            writer.tag(4, WireType.Varint).int32(message.scheduleRelationship);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message transit_realtime.TripDescriptor
 */
export const TripDescriptor = new TripDescriptor$Type();
// @generated message type with reflection information, may provide speed optimized methods
class VehicleDescriptor$Type extends MessageType<VehicleDescriptor> {
    constructor() {
        super("transit_realtime.VehicleDescriptor", [
            { no: 1, name: "id", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "label", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "license_plate", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<VehicleDescriptor>): VehicleDescriptor {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<VehicleDescriptor>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: VehicleDescriptor): VehicleDescriptor {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string id */ 1:
                    message.id = reader.string();
                    break;
                case /* optional string label */ 2:
                    message.label = reader.string();
                    break;
                case /* optional string license_plate */ 3:
                    message.licensePlate = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: VehicleDescriptor, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string id = 1; */
        if (message.id !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* optional string label = 2; */
        if (message.label !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.label);
        /* optional string license_plate = 3; */
        if (message.licensePlate !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.licensePlate);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message transit_realtime.VehicleDescriptor
 */
export const VehicleDescriptor = new VehicleDescriptor$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EntitySelector$Type extends MessageType<EntitySelector> {
    constructor() {
        super("transit_realtime.EntitySelector", [
            { no: 1, name: "agency_id", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "route_id", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "route_type", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "trip", kind: "message", T: () => TripDescriptor },
            { no: 5, name: "stop_id", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<EntitySelector>): EntitySelector {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EntitySelector>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EntitySelector): EntitySelector {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string agency_id */ 1:
                    message.agencyId = reader.string();
                    break;
                case /* optional string route_id */ 2:
                    message.routeId = reader.string();
                    break;
                case /* optional int32 route_type */ 3:
                    message.routeType = reader.int32();
                    break;
                case /* optional transit_realtime.TripDescriptor trip */ 4:
                    message.trip = TripDescriptor.internalBinaryRead(reader, reader.uint32(), options, message.trip);
                    break;
                case /* optional string stop_id */ 5:
                    message.stopId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EntitySelector, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string agency_id = 1; */
        if (message.agencyId !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.agencyId);
        /* optional string route_id = 2; */
        if (message.routeId !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.routeId);
        /* optional int32 route_type = 3; */
        if (message.routeType !== undefined)
            writer.tag(3, WireType.Varint).int32(message.routeType);
        /* optional transit_realtime.TripDescriptor trip = 4; */
        if (message.trip)
            TripDescriptor.internalBinaryWrite(message.trip, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* optional string stop_id = 5; */
        if (message.stopId !== undefined)
            writer.tag(5, WireType.LengthDelimited).string(message.stopId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message transit_realtime.EntitySelector
 */
export const EntitySelector = new EntitySelector$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TranslatedString$Type extends MessageType<TranslatedString> {
    constructor() {
        super("transit_realtime.TranslatedString", [
            { no: 1, name: "translation", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TranslatedString_Translation }
        ]);
    }
    create(value?: PartialMessage<TranslatedString>): TranslatedString {
        const message = { translation: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TranslatedString>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TranslatedString): TranslatedString {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated transit_realtime.TranslatedString.Translation translation */ 1:
                    message.translation.push(TranslatedString_Translation.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TranslatedString, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated transit_realtime.TranslatedString.Translation translation = 1; */
        for (let i = 0; i < message.translation.length; i++)
            TranslatedString_Translation.internalBinaryWrite(message.translation[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message transit_realtime.TranslatedString
 */
export const TranslatedString = new TranslatedString$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TranslatedString_Translation$Type extends MessageType<TranslatedString_Translation> {
    constructor() {
        super("transit_realtime.TranslatedString.Translation", [
            { no: 1, name: "text", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "language", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<TranslatedString_Translation>): TranslatedString_Translation {
        const message = { text: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TranslatedString_Translation>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TranslatedString_Translation): TranslatedString_Translation {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string text */ 1:
                    message.text = reader.string();
                    break;
                case /* optional string language */ 2:
                    message.language = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TranslatedString_Translation, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string text = 1; */
        if (message.text !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.text);
        /* optional string language = 2; */
        if (message.language !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.language);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message transit_realtime.TranslatedString.Translation
 */
export const TranslatedString_Translation = new TranslatedString_Translation$Type();
